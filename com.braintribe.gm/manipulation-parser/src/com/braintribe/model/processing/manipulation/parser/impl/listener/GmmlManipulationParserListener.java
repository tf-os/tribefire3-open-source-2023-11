// ============================================================================
// Copyright BRAINTRIBE TECHNOLOGY GMBH, Austria, 2002-2022
// 
// This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
// 
// This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License along with this library; See http://www.gnu.org/licenses/.
// ============================================================================
package com.braintribe.model.processing.manipulation.parser.impl.listener;

import static com.braintribe.model.generic.manipulation.DeleteMode.dropReferences;
import static com.braintribe.model.generic.manipulation.DeleteMode.ignoreReferences;
import static com.braintribe.model.generic.value.EntityReferenceType.preliminary;
import static com.braintribe.utils.lcd.CollectionTools2.newMap;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

import org.antlr.v4.runtime.tree.ErrorNode;
import org.antlr.v4.runtime.tree.TerminalNode;

import com.braintribe.model.generic.GMF;
import com.braintribe.model.generic.GenericEntity;
import com.braintribe.model.generic.manipulation.AcquireManipulation;
import com.braintribe.model.generic.manipulation.AddManipulation;
import com.braintribe.model.generic.manipulation.AtomicManipulation;
import com.braintribe.model.generic.manipulation.ChangeValueManipulation;
import com.braintribe.model.generic.manipulation.ClearCollectionManipulation;
import com.braintribe.model.generic.manipulation.DeleteManipulation;
import com.braintribe.model.generic.manipulation.DeleteMode;
import com.braintribe.model.generic.manipulation.EntityProperty;
import com.braintribe.model.generic.manipulation.InstantiationManipulation;
import com.braintribe.model.generic.manipulation.PropertyManipulation;
import com.braintribe.model.generic.manipulation.RemoveManipulation;
import com.braintribe.model.generic.reflection.EntityType;
import com.braintribe.model.generic.value.EntityReference;
import com.braintribe.model.generic.value.EnumReference;
import com.braintribe.model.generic.value.GlobalEntityReference;
import com.braintribe.model.generic.value.PreliminaryEntityReference;
import com.braintribe.model.processing.manipulation.parser.api.GmmlParserConfiguration;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.AddContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.BlockContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.BlockSequenceContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.ChangeValueContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.ClearContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.CollectionDeltaValueContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.CustomInstanceContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.CustomManipulationContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.DeleteManipulationContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.EnumValueContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.InstanceAcquireContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.InstanceCreationContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.InstanceLookupContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.ListDeltaValueContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.ManipulationBlockContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.ManipulationBlocksContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.ManipulationContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.ManipulationOperationContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.MapDeltaValueContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.PropertyEntryContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.PropertyManipulationContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.PropertyOwnerContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.QualifiedTypeAssignmentContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.QualifiedTypeContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.RemoveContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.SetDeltaValueContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.SingleDeltaValueContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.StatementContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.ValueAssignmentContext;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser.VariableStatementContext;

public class GmmlManipulationParserListener extends GmmlValueParserListener {
	private final Map<String, Object> variables;
	private EntityReference lastReference; // either Preliminary or Global
	private Consumer<? super AtomicManipulation> manipulationConsumer;

	public GmmlManipulationParserListener(GmmlParserConfiguration configuration) {
		this.variables = configuration.variables();
	}

	public void setManipulationConsumer(Consumer<? super AtomicManipulation> manipulationConsumer) {
		this.manipulationConsumer = manipulationConsumer;
	}

	public Map<String, Object> getVariables() {
		return variables;
	}

	@Override
	public void enterQualifiedTypeAssignment(QualifiedTypeAssignmentContext ctx) {
		// noop
	}

	@Override
	public void exitQualifiedTypeAssignment(QualifiedTypeAssignmentContext ctx) {
		String qualifiedTypeName = pop();
		String variableName = pop();

		variables.put(variableName, qualifiedTypeName);
		push(qualifiedTypeName);
	}

	@Override
	public void enterQualifiedType(QualifiedTypeContext ctx) {
		// noop
	}

	@Override
	public void exitQualifiedType(QualifiedTypeContext ctx) {
		// noop - we have typeSignature (qualifiedIdentifier) on top of the stack and want to keep it that way
	}

	@Override
	public void enterValueAssignment(ValueAssignmentContext ctx) {
		// noop
	}

	@Override
	public void exitValueAssignment(ValueAssignmentContext ctx) {
		Object value = pop();
		String variableName = pop();

		variables.put(variableName, value);
		push(value);
	}

	@Override
	public void enterInstanceCreation(InstanceCreationContext ctx) {
		// noop
	}

	@Override
	public void exitInstanceCreation(InstanceCreationContext ctx) {
		String typeSignature = pop();
		String variableName = pop();

		PreliminaryEntityReference reference = PreliminaryEntityReference.T.create();
		reference.setTypeSignature(typeSignature);
		reference.setRefId(reference.runtimeId());

		InstantiationManipulation manipulation = InstantiationManipulation.T.create();
		manipulation.setEntity(reference);
		manipulationConsumer.accept(manipulation);

		variables.put(variableName, reference);
		push(reference);

		notifyReference(reference);
	}

	@Override
	public void enterInstanceLookup(InstanceLookupContext ctx) {
		// noop
	}

	@Override
	public void exitInstanceLookup(InstanceLookupContext ctx) {
		String globalId = pop();
		String typeSignature = pop();
		String variableName = pop();

		GlobalEntityReference reference = GlobalEntityReference.T.create();
		reference.setTypeSignature(typeSignature);
		reference.setRefId(globalId);

		variables.put(variableName, reference);
		push(reference);

		notifyReference(reference);
	}

	@Override
	public void enterInstanceAcquire(InstanceAcquireContext ctx) {
		// noop
	}

	@Override
	public void exitInstanceAcquire(InstanceAcquireContext ctx) {
		String globalId = pop();
		String typeSignature = pop();
		String variableName = pop();

		GlobalEntityReference reference = GlobalEntityReference.T.create();
		reference.setTypeSignature(typeSignature);
		reference.setRefId(globalId);

		AcquireManipulation manipulation = AcquireManipulation.T.create();
		manipulation.setEntity(reference);
		manipulation.setEntityGlobalId(globalId);

		manipulationConsumer.accept(manipulation);

		variables.put(variableName, reference);
		push(reference);

		notifyReference(reference);
	}

	private void notifyReference(EntityReference reference) {
		if (!insideVariableAssignmentValue)
			lastReference = reference;
	}

	@Override
	public void enterVariableStatement(VariableStatementContext ctx) {
		// noop
	}

	@Override
	public void exitVariableStatement(VariableStatementContext ctx) {
		pop();
	}

	@Override
	public void enterCollectionDeltaValue(CollectionDeltaValueContext ctx) {
		// noop
	}

	@Override
	public void exitCollectionDeltaValue(CollectionDeltaValueContext ctx) {
		// noop
	}

	@Override
	public void enterSetDeltaValue(SetDeltaValueContext ctx) {
		// noop
	}

	@Override
	public void exitSetDeltaValue(SetDeltaValueContext ctx) {
		Set<Object> set = pop();
		Map<Object, Object> map = newMap();
		for (Object element : set)
			map.put(element, element);

		push(map);
	}

	@Override
	public void enterMapDeltaValue(MapDeltaValueContext ctx) {
		// noop
	}

	@Override
	public void exitMapDeltaValue(MapDeltaValueContext ctx) {
		// noop - we already have a map on the stack
	}

	@Override
	public void enterSingleDeltaValue(SingleDeltaValueContext ctx) {
		// noop
	}

	@Override
	public void exitSingleDeltaValue(SingleDeltaValueContext ctx) {
		Object value = pop();
		Map<Object, Object> map = new HashMap<>();
		map.put(value, value);
		push(map);
	}

	@Override
	protected <T> T requireVariable(String name) {
		Object variableValue = variables.get(name);

		if (variableValue == null)
			throw new IllegalStateException("variable " + name + " is undefined");

		return (T) variableValue;
	}

	@Override
	public void enterManipulationBlock(ManipulationBlockContext ctx) {
		// noop
	}

	@Override
	public void exitManipulationBlock(ManipulationBlockContext ctx) {
		variables.clear();
	}

	@Override
	public void enterManipulation(ManipulationContext ctx) {
		// noop
	}

	@Override
	public void exitManipulation(ManipulationContext ctx) {
		// noop
	}

	@Override
	public void enterDeleteManipulation(DeleteManipulationContext ctx) {
		// noop
	}

	@Override
	public void exitDeleteManipulation(DeleteManipulationContext ctx) {
		EntityReference reference = pop();

		DeleteMode mode = reference.referenceType() == preliminary ? ignoreReferences : dropReferences;

		DeleteManipulation manipulation = DeleteManipulation.T.create();
		manipulation.setEntity(reference);
		manipulation.setDeleteMode(mode);

		manipulationConsumer.accept(manipulation);
	}

	@Override
	public void enterCustomManipulation(CustomManipulationContext ctx) {
		// noop
	}

	@Override
	public void exitCustomManipulation(CustomManipulationContext ctx) {
		AtomicManipulation customManipulation = pop();
		manipulationConsumer.accept(customManipulation);
	}

	@Override
	public void enterCustomInstance(CustomInstanceContext ctx) {
		// noop
	}

	@Override
	public void exitCustomInstance(CustomInstanceContext ctx) {
		String typeSignature = pop();

		EntityType<?> entityType = GMF.getTypeReflection().getType(typeSignature);

		GenericEntity entity = entityType.createRaw();
		push(entity);
	}

	@Override
	public void enterPropertyEntry(PropertyEntryContext ctx) {
		// noop
	}

	@Override
	public void exitPropertyEntry(PropertyEntryContext ctx) {
		Object value = pop();
		GenericEntity entity = peek();

		String propertyName = ctx.StandardIdentifier().getText();

		entity.entityType().getProperty(propertyName).set(entity, value);
	}

	@Override
	public void enterPropertyManipulation(PropertyManipulationContext ctx) {
		// noop
	}

	@Override
	public void exitPropertyManipulation(PropertyManipulationContext ctx) {
		PropertyManipulation manipulation = pop();

		EntityProperty entityProperty = EntityProperty.T.create();
		entityProperty.setReference(lastReference);
		entityProperty.setPropertyName(ctx.StandardIdentifier().getText());

		manipulation.setOwner(entityProperty);

		manipulationConsumer.accept(manipulation);
	}

	@Override
	public void enterPropertyOwner(PropertyOwnerContext ctx) {
		// noop
	}

	@Override
	public void exitPropertyOwner(PropertyOwnerContext ctx) {
		lastReference = pop();
	}

	@Override
	public void enterAdd(AddContext ctx) {
		// noop
	}

	@Override
	public void exitAdd(AddContext ctx) {
		Map<Object, Object> itemsToAdd = pop();

		AddManipulation add = AddManipulation.T.create();
		add.setItemsToAdd(itemsToAdd);
		push(add);
	}

	@Override
	public void enterBlockSequence(BlockSequenceContext ctx) {
		// noop
	}

	@Override
	public void exitBlockSequence(BlockSequenceContext ctx) {
		// noop
	}

	@Override
	public void enterBlock(BlockContext ctx) {
		// noop
	}

	@Override
	public void exitBlock(BlockContext ctx) {
		// noop
	}

	@Override
	public void enterRemove(RemoveContext ctx) {
		// noop
	}

	@Override
	public void exitRemove(RemoveContext ctx) {
		Map<Object, Object> itemsToRemove = pop();

		RemoveManipulation remove = RemoveManipulation.T.create();
		remove.setItemsToRemove(itemsToRemove);
		push(remove);
	}

	@Override
	public void enterListDeltaValue(ListDeltaValueContext ctx) {
		// noop
	}

	@Override
	public void exitListDeltaValue(ListDeltaValueContext ctx) {
		// noop
	}

	@Override
	public void enterStatement(StatementContext ctx) {
		// noop
	}

	@Override
	public void exitStatement(StatementContext ctx) {
		// noop
	}

	@Override
	public void enterManipulationBlocks(ManipulationBlocksContext ctx) {
		// noop
	}

	@Override
	public void exitManipulationBlocks(ManipulationBlocksContext ctx) {
		// noop
	}

	@Override
	public void enterManipulationOperation(ManipulationOperationContext ctx) {
		// noop
	}

	@Override
	public void exitManipulationOperation(ManipulationOperationContext ctx) {
		// noop
	}

	@Override
	public void enterClear(ClearContext ctx) {
		// noop
	}

	@Override
	public void exitClear(ClearContext ctx) {
		push(ClearCollectionManipulation.T.create());
	}

	@Override
	public void enterChangeValue(ChangeValueContext ctx) {
		// noop
	}

	@Override
	public void exitChangeValue(ChangeValueContext ctx) {
		Object value = pop();
		ChangeValueManipulation cvm = ChangeValueManipulation.T.create();
		cvm.setNewValue(value);
		push(cvm);
	}

	@Override
	public void visitErrorNode(ErrorNode arg0) {
		// noop
	}

	@Override
	public void visitTerminal(TerminalNode arg0) {
		// noop
	}

	@Override
	public void enterEnumValue(EnumValueContext ctx) {
		// noop
	}

	@Override
	public void exitEnumValue(EnumValueContext ctx) {
		String enumTypeSignature = pop();
		String enumConstantName = ctx.StandardIdentifier().getText();

		EnumReference enumReference = EnumReference.T.create();
		enumReference.setTypeSignature(enumTypeSignature);
		enumReference.setConstant(enumConstantName);

		push(enumReference);
	}

}