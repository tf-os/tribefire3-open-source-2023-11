// ============================================================================
// Copyright BRAINTRIBE TECHNOLOGY GMBH, Austria, 2002-2022
// 
// This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
// 
// This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License along with this library; See http://www.gnu.org/licenses/.
// ============================================================================
package com.braintribe.model.processing.manipulation.parser.impl;

import org.antlr.v4.runtime.BailErrorStrategy;
import org.antlr.v4.runtime.BaseErrorListener;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.InputMismatchException;
import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Recognizer;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.TokenStream;
import org.antlr.v4.runtime.UnbufferedCharStream;
import org.antlr.v4.runtime.misc.Interval;

import com.braintribe.exception.Exceptions;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParser;

/**
 * ANTLR doesn't handle exceptions in listener very well. If for example an exception happens in an exit event of some rule, the exit event of the
 * parent rule is called (from a finally block). Since we are using a stack in our exit methods, this would normally lead to other problems due to the
 * stack's pollution, thus losing the original exception.
 * 
 * To avoid this, we use this "sane" parser that avoids calling exit events in case of an exception, and making the exception available to be
 * re-thrown by the user of this parser.
 * 
 * Another things we handle is correctly display the context in case an error happened, to identify the exact spot where the input is broken. Other
 * than propagating the line/offset values of the first mismatching token, we also display the GMML input at that spot. The input displayed ends at
 * the token that doesn't fit, and starts at s the furthest of these positions:
 * <ol>
 * <li>beginning of the very first token</li>
 * <li>beginning of the current current statement rule</li>
 * <li>beginning of the current line</li>
 * </ol>
 * 
 * @author peter.gazdik
 */
public class GmmlSaneParser extends GmmlParser {

	private Throwable errorOrRuntimeException;

	public void throwErrorOrRuntimeExceptionIfYouAreAwareOfOne() {
		if (errorOrRuntimeException == null)
			return;

		if (errorOrRuntimeException instanceof Error)
			throw (Error) errorOrRuntimeException;
		else
			throw (RuntimeException) errorOrRuntimeException;
	}

	protected final CharStream charStream;
	protected Token firstStatementToken;

	/* package */ boolean skipExitRules;

	public GmmlSaneParser(TokenStream input, CharStream charStream) {
		this(input, charStream, false);
	}

	// This constructor is called by the "unbuffered" sub-type and allows for the charStream to be a
	protected GmmlSaneParser(TokenStream input, CharStream charStream, boolean allowUnbufferdCharStream) {
		super(input);
		this.charStream = charStream;

		removeErrorListeners(); // remove ConsoleErrorListener
		addErrorListener(new GmmlErrorListener());
		setErrorHandler(GmmlErrorStrategy.INSTANCE);

		if (!allowUnbufferdCharStream && charStream instanceof UnbufferedCharStream)
			throw new IllegalArgumentException(
					"Cannot use 'UnbufferedCharStream' with GmmlSaneParser. Either use a different charSteram, or GmmlUnbufferedSaneParser.");
	}

	@Override
	public void enterRule(ParserRuleContext localctx, int state, int ruleIndex) {
		if (isNewStatementStart(ruleIndex))
			firstStatementToken = getCurrentToken();

		try {
			super.enterRule(localctx, state, ruleIndex);

		} catch (Error e) {
			throwOnRuleError(e);

		} catch (RuntimeException e) {
			throwOnRuleException(e);
		}
	}

	protected boolean isNewStatementStart(int ruleIndex) {
		return firstStatementToken == null || ruleIndex == GmmlParser.RULE_statement;
	}

	@Override
	public void exitRule() {
		if (skipExitRules)
			return;

		try {
			super.exitRule();

		} catch (Error e) {
			throwOnRuleError(e);

		} catch (RuntimeException e) {
			throwOnRuleException(e);
		}
	}

	private void throwOnRuleError(Error e) {
		skipExitRules = true;
		throw e;
	}

	private void throwOnRuleException(RuntimeException e) {
		skipExitRules = true;

		RuntimeException re = Exceptions.contextualize(e, contextMessage());
		errorOrRuntimeException = re;

		throw re;
	}

	private String contextMessage() {
		Token t = getCurrentToken();
		int positionInLine = t.getCharPositionInLine();
		String sourceWithError = getSourceWithError(t, positionInLine);

		return "Runtime error in line " + t.getLine() + " at position " + positionInLine + ". Source: \"" + sourceWithError + "\"";
	}

	private String getSourceWithError(Object _token, int positionInLine) {
		if (!(_token instanceof Token))
			return "<unknown>: " + _token;

		Token token = (Token) _token;

		int errorTokenStart = token.getStartIndex();
		int lineStart = errorTokenStart - positionInLine;

		int statementStart = firstStatementToken.getStartIndex();

		if (lineStart <= statementStart)
			return getSource(statementStart, errorTokenStart);
		else
			return getSource(lineStart, errorTokenStart);
	}

	protected String getSource(int start, int end) {
		return charStream.getText(new Interval(start, end));
	}

	class GmmlErrorListener extends BaseErrorListener {

		@Override
		public void syntaxError(Recognizer<?, ?> recognizer, Object maybeToken, int lineNumber, int positionInLine, String errorMessage,
				RecognitionException arg5) {

			String lineWithError = getSourceWithError(maybeToken, positionInLine);

			errorOrRuntimeException = new IllegalStateException(
					errorMessage + " in line " + lineNumber + " at position " + positionInLine + ". Source: \"" + lineWithError + "\"");
			skipExitRules = true;
		}

	}

	static class GmmlErrorStrategy extends BailErrorStrategy {

		public static final GmmlErrorStrategy INSTANCE = new GmmlErrorStrategy();

		@Override
		protected void beginErrorCondition(Parser recognizer) {
			// DO NOT DELETE! noop on purpose
		}

		@Override
		public Token recoverInline(Parser parser) throws RecognitionException {
			/* If we don't do this, the default implementation throws ParseCancellationException, which hides the actual syntax problem. */
			throw new InputMismatchException(parser);
		}

	}

}

class GmmlUnbufferedSaneParser extends GmmlSaneParser {

	public GmmlUnbufferedSaneParser(TokenStream input, UnbufferedCharStream charStream) {
		super(input, charStream, true);

		charStream.mark();
	}

	@Override
	public void enterRule(ParserRuleContext localctx, int state, int ruleIndex) {
		/* If new statement is starting, we update the stream marker. This means we can get text out of the stream from this position on - i.e.
		 * everything we might need except maybe for the first token (which we have already consumed). This token is stored separately in the
		 * superclass. */
		if (isNewStatementStart(ruleIndex)) {
			// -1 in the id of the marker - as we always have exactly one marker, we always release with -1
			charStream.release(-1);
			charStream.mark();
		}

		super.enterRule(localctx, state, ruleIndex);
	}

	@Override
	protected String getSource(int start, int end) {
		try {
			return tryGetSource(start, end);

		} catch (Exception e) {
			// Just in case there is still some way we might use invalid bounds for the underlying unbuffered stream
			return "unknown";
		}
	}

	private String tryGetSource(int start, int end) {
		boolean isStartOfStatement = (start == firstStatementToken.getStartIndex());

		if (isStartOfStatement) {
			String t = firstStatementToken.getText();
			return t + charStream.getText(new Interval(start + t.length(), end));
		} else
			return charStream.getText(new Interval(start, end));
	}
}
