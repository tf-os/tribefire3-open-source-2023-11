// ============================================================================
// Copyright BRAINTRIBE TECHNOLOGY GMBH, Austria, 2002-2022
// 
// This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
// 
// This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License along with this library; See http://www.gnu.org/licenses/.
// ============================================================================
package com.braintribe.model.processing.manipulation.parser.impl;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringReader;
import java.util.List;
import java.util.Set;
import java.util.function.Consumer;

import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CommonTokenFactory;
import org.antlr.v4.runtime.DiagnosticErrorListener;
import org.antlr.v4.runtime.UnbufferedCharStream;
import org.antlr.v4.runtime.UnbufferedTokenStream;
import org.antlr.v4.runtime.atn.PredictionMode;

import com.braintribe.model.generic.manipulation.AtomicManipulation;
import com.braintribe.model.generic.manipulation.Manipulation;
import com.braintribe.model.generic.manipulation.VoidManipulation;
import com.braintribe.model.generic.manipulation.util.ManipulationBuilder;
import com.braintribe.model.generic.tracking.ManipulationCollector;
import com.braintribe.model.generic.tracking.StandardManipulationCollector;
import com.braintribe.model.processing.manipulation.parser.api.GmmlParserConfiguration;
import com.braintribe.model.processing.manipulation.parser.api.GmmlParserException;
import com.braintribe.model.processing.manipulation.parser.api.ParseResponse;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlLexer;
import com.braintribe.model.processing.manipulation.parser.impl.autogenerated.GmmlParserListener;
import com.braintribe.model.processing.manipulation.parser.impl.listener.GmmlManipulationParserListener;
import com.braintribe.model.processing.manipulation.parser.impl.listener.HomeopathyDetectingParserListener;

public class ManipulationParser {

	public static Manipulation parse(String text) {
		StringReader reader = new StringReader(text);
		return parse(reader);
	}

	public static Manipulation parse(InputStream in, String charset) throws IOException {
		Reader reader = new InputStreamReader(in, charset);
		return parse(reader);
	}

	public static Manipulation parse(InputStream in, String charset, GmmlParserConfiguration config) throws IOException {
		Reader reader = new InputStreamReader(in, charset);
		return parse(reader, config);
	}

	public static Manipulation parse(Reader reader) {
		return parse(reader, Gmml.configuration());
	}

	public static Manipulation parse(Reader reader, GmmlParserConfiguration config) {
		ManipulationCollector manipulationCollector = new StandardManipulationCollector();

		parse(reader, manipulationCollector::noticeManipulation, config);

		List<Manipulation> manipulations = manipulationCollector.getManipulations();

		switch (manipulations.size()) {
			case 0:
				return VoidManipulation.T.create();
			case 1:
				return manipulations.get(0);
			default:
				return ManipulationBuilder.compound(manipulations);
		}
	}

	public static ParseResponse parse(Reader reader, Consumer<? super AtomicManipulation> manipulationConsumer, GmmlParserConfiguration config) {
		GmmlManipulationParserListener listener = new GmmlManipulationParserListener(config);
		listener.setManipulationConsumer(manipulationConsumer);

		parse(reader, config, listener);

		ParseResponse result = new ParseResponse();
		result.variables = listener.getVariables();
		result.lastAssignment = null;

		return result;
	}

	public static Set<String> findHomeopathicVariables(Reader reader, GmmlParserConfiguration config) {
		HomeopathyDetectingParserListener listener = new HomeopathyDetectingParserListener();
		parse(reader, config, listener);
		return listener.homeopathincVariables();
	}
	
	/* package */ static void parse(Reader reader, GmmlParserConfiguration config, GmmlParserListener listener) {
		GmmlSaneParser parser = null;

		try {
			parser = newParser(reader, config);
			parser.addParseListener(listener);

			if (config.parseSingleBlock())
				parser.block();
			else
				parser.blockSequence();

		} catch (Exception e) {
			if (parser != null)
				parser.throwErrorOrRuntimeExceptionIfYouAreAwareOfOne();

			// Some exception happened without the parser being aware of it
			throw new GmmlParserException("Error while parsing manipulations", e);
		}
	}

	public static GmmlSaneParser newParser(Reader reader, GmmlParserConfiguration config) {
		GmmlSaneParser parser = config.bufferEntireInput() ? newBufferedParserFor(reader) : newUnbufferedParserFor(reader);

		parser.setBuildParseTree(false);
		parser.addErrorListener(new DiagnosticErrorListener()); // To detect ambiguity
		parser.getInterpreter().setPredictionMode(PredictionMode.LL); // SLL once the grammar is changed and works
		
		return parser;
	}
	
	private static GmmlSaneParser newBufferedParserFor(Reader reader) {
		CharStream charStream = newANTLRInputStream(reader);

		GmmlLexer lexer = new GmmlLexer(charStream);
		lexer.removeErrorListeners();

		return new GmmlSaneParser(new UnbufferedTokenStream<>(lexer), charStream);
	}

	private static ANTLRInputStream newANTLRInputStream(Reader reader) {
		try {
			return new ANTLRInputStream(reader);
		
		} catch (IOException e) {
			throw new RuntimeException("Error while createing ANTLRInputStream", e);
		}
	}

	private static GmmlSaneParser newUnbufferedParserFor(Reader reader) {
		UnbufferedCharStream charStream = new UnbufferedCharStream(reader);

		GmmlLexer lexer = new GmmlLexer(charStream);
		lexer.removeErrorListeners();
		lexer.setTokenFactory(new CommonTokenFactory(true));

		return new GmmlUnbufferedSaneParser(new UnbufferedTokenStream<>(lexer), charStream);
	}
}
