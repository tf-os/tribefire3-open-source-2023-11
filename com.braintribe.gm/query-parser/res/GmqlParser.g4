// ============================================================================
// Braintribe IT-Technologies GmbH - www.braintribe.com
// Copyright Braintribe-IT Technologies GmbH, Austria, 2002-2015 - All Rights Reserved
// It is strictly forbidden to copy, modify, distribute or use this code without written permission
// To this file the Braintribe License Agreement applies.
// ============================================================================
parser grammar GmqlParser;

options {
	tokenVocab = GmqlLexer;
}

@header {
package com.braintribe.model.processing.query.parser.impl.autogenerated;
}

// root rule

evaluate: query EOF;

query:
	entityQuery
	| propertyQuery
	| selectQuery
;

//-------------Select Query-------

selectQuery: selectQueryStart queryTailWhere? selectQueryTailGroupBy? selectQueryTailHaving? queryTailOrderBy? queryTailPagination?;

selectQueryStart: selectQueryHead selectQueryFrom selectQueryJoin?;

selectQueryHead: Select Distinct? selectQuerySelection;

selectQuerySelection:
	Star
	| selectQuerySingleSelection (COMMA selectQuerySingleSelection)*
;

selectQuerySingleSelection: value;

selectQueryFrom: From selectQuerySingleFrom (COMMA selectQuerySingleFrom)*;
selectQuerySingleFrom: identifier alias?;
selectQueryJoin: join+;

selectQueryTailGroupBy:	groupBy;
selectQueryTailHaving: havingCondition;

//------------Group by-----------

groupBy: GroupBy groupByExpression (COMMA groupByExpression)*;
groupByExpression: value;

//------------Having-----------

havingCondition: Having booleanValueExpression;

//-------------Join---------------

join: joinType identifier alias?;

joinType
:
	innerJoin
	| fullJoin
	| leftJoin
	| rightJoin
;

innerJoin: Join;
fullJoin: Full Join;
leftJoin: Left Join;
rightJoin: Right Join;

//-------------Property Query -----

propertyQuery: propertyQueryStart queryTailWhere? queryTailOrderBy? queryTailPagination?;

propertyQueryStart: Distinct? Property propertyQueryHead Of entityReference;
propertyQueryHead: identifier alias?;

//-------------Entity Query -----

entityQuery: entityQueryStart queryTailWhere? queryTailOrderBy? queryTailPagination?;

entityQueryStart: Distinct? From entityQueryHead;
entityQueryHead: identifier alias?;

//------------Query Tail ---------

queryTailWhere: whereCondition;
queryTailOrderBy: orderBy;
queryTailPagination: pagination;

//-----------Aggregate functions----- (For select queries only)

aggregateFunction:
	aggregateCount
	| aggregateAvg
	| aggregateMin
	| aggregateMax
	| aggregateSum
;

aggregateAvg: AggAvg LB sourceProperty RB;
aggregateMin: AggMin LB sourceProperty RB;
aggregateMax: AggMax LB sourceProperty RB;
aggregateSum: AggSum LB sourceProperty RB;
aggregateCount: AggCount LB sourceProperty (COMMA booleanValue)? RB;

//-------------Order By----------

orderBy: OrderBy orderBySingle (COMMA orderBySingle)*;
orderBySingle: orderByExpression orderByDirection?;

orderByDirection:
	Ascending # ascendingOrderByDirection
	| Descending # descendingOrderByDirection
;

orderByExpression: value;

//------------Pagination----------

pagination
:
	Limit limit = integerValue  (Offset offset = integerValue )? # paginationLimit
	| Offset integerValue # paginationOffset
;

//--------------Alias--------------

alias: genericIdentifier;

//---------------Where--------------

whereCondition: Where booleanValueExpression;

//------------------ boolean expressions ---------------------

// AND has higher precedence than OR, so OR has to be defined first (http://www.ifi.uzh.ch/ailab/teaching/formalmethods2013/Solution3_2013.pdf)
// https://wincent.com/wiki/ANTLR_grammar_problems

booleanValueExpression: orPredicate;
orPredicate: andPredicate (Or andPredicate)*;
andPredicate: negationPredicate (And negationPredicate)*;
negationPredicate: Not? booleanAtomicExpression;

booleanAtomicExpression:
	parenthesizedBooleanValueExpression
	| comparison
;

parenthesizedBooleanValueExpression: LB booleanValueExpression RB;

//-----------Boolean functions------

// IN QP3.0 add more functions here e.g. ToBoolean
// update in QP3.0 to handle the case of having literalValues as valid parts for the conjunction

booleanFunction: fullTextComparison;
fullTextComparison: FullText LB (alias COMMA)? stringValue RB;


//--------------------Comparison--------------------------

comparison:
	leftOperand = value Operator rightOperand = value # predicateComparison
	| booleanFunction # booleanFunctionComparison
;

value:
	literalValue
	| nullValue
	| entityReference
	| enumReference
	| sourceProperty
	| stringFunction
	| booleanFunction
	| dateFunction
	| typeSignature
	| collection
	| variable
	| generalValue
	| contextFunction
;

generalValue:
	joinFunction
	| aggregateFunction
;
// -----------Variable-----------

variable: Colon identifier ( LB identifier (COMMA value)? RB )?;

//-----------List----------------

collection: LB value (COMMA value)* RB;

//-----------Date functions---------

dateFunction: now;

now: Now LB RB;

//-----------Context functions---------

contextFunction: username;
username: Username LB RB;

//-----------String functions--------

stringFunction:
	lower
	| upper
	| toStringRule
	| concatenation
	| localize
;

lower: Lower LB stringFunctionParameter RB;
upper: Upper LB stringFunctionParameter RB;

toStringRule: ToStringToken LB stringFunctionParameter RB;

concatenation: Concatenation LB stringFunctionParameter (COMMA stringFunctionParameter)* RB;

stringFunctionParameter:
	stringValue
	| stringFunction
	| sourceProperty
;

localize: Localize LB value COMMA stringValue RB;

//--------------------Source Property------------------

sourceProperty: identifier;

//--------------------Join Functions--------------------

joinFunction:
	listIndex
	| mapKey
;

listIndex: ListIndex LB alias RB;

mapKey: MapKey LB alias RB;

//---------------------Enum------------------------------

enumReference: Enum LB identifier COMMA genericIdentifier RB;

//---------------------Entity-----------------------------

entityReference: Entity LB identifier COMMA value (COMMA stringValue)? (COMMA booleanValue)? RB;

typeSignature: TypeSignature LB value RB;

//--------identifiers---------------

identifier: genericIdentifier (Dot genericIdentifier)*;

genericIdentifier:
	StandardIdentifier # standardIdentifier
	| escapedIdentifier # keyWordIdentifier
;

escapedIdentifier: EscapedIdentifier KeyWord EscapedIdentifierClose;

//--------------------Literal Values----------------------

literalValue:
	booleanValue
	| floatValue
	| doubleValue
	| decimalValue
	| integerValue
	| longValue
	| stringValue
	| dateValue
;

//----------------------Date----------------------------

dateValue: DateFunction calendarOffsetValue (COMMA calendarOffsetValue)* RB;

calendarOffsetValue:
	dateOffset
	| timeZoneOffset
;

dateOffset: DateOffset;
timeZoneOffset: TimeZoneOffset;

// ---------------------String--------------------------

stringValue:
	StringOpen
	(
		escape
		| plainContent
	)* StringClose
;

escape:
	EscB # EscB
	| EscBS # EscBS
	| EscF # EscF
	| EscN # EscN
	| EscR # EscR
	| EscSQ # EscSQ
	| EscT # EscT
	| UnicodeEscape # UnicodeEscape
;

plainContent: PlainContent;

//-------------------Simple literals----------------------

nullValue: Null;
booleanValue: Boolean;
decimalValue: DecimalLiteral;
floatValue: FloatLiteral;
doubleValue: DoubleLiteral;

integerValue:
	IntegerBase16Literal # IntegerHexRepresentation
	| IntegerBase10Literal # IntegerDecimalRepresenation
;

longValue:
	LongBase16Literal # LongHexRepresentation
	| LongBase10Literal # LongDecimalRepresenation
;
