// ============================================================================
// Copyright BRAINTRIBE TECHNOLOGY GMBH, Austria, 2002-2022
// 
// This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
// 
// This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License along with this library; See http://www.gnu.org/licenses/.
// ============================================================================
package com.braintribe.model.processing.query.parser.impl.listener;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.antlr.v4.runtime.ParserRuleContext;

import com.braintribe.model.generic.GenericEntity;
import com.braintribe.model.generic.value.Variable;
import com.braintribe.model.processing.query.parser.api.GmqlQueryParserException;
import com.braintribe.model.processing.query.parser.api.SourceRegistry;
import com.braintribe.model.processing.query.parser.impl.DefaultSource;
import com.braintribe.model.processing.query.parser.impl.FragmentsBuilder;
import com.braintribe.model.processing.query.parser.impl.RegistryManager;
import com.braintribe.model.processing.query.parser.impl.SourceLink;
import com.braintribe.model.processing.query.parser.impl.autogenerated.GmqlParserBaseListener;
import com.braintribe.model.processing.query.parser.impl.context.CustomContext;
import com.braintribe.model.processing.query.parser.impl.context.basetype.DefaultCustomContext;
import com.braintribe.model.query.Join;
import com.braintribe.model.query.PropertyOperand;
import com.braintribe.model.query.Query;
import com.braintribe.model.query.Source;
import com.braintribe.model.query.conditions.FulltextComparison;
import com.braintribe.model.query.functions.ListIndex;
import com.braintribe.model.query.functions.MapKey;

public abstract class GmqlBasicParserListener extends GmqlParserBaseListener {

	protected Map<ParserRuleContext, CustomContext<?>> contextMap = new HashMap<ParserRuleContext, CustomContext<?>>();
	protected SourceRegistry registryManager = new RegistryManager();
	protected FragmentsBuilder $ = new FragmentsBuilder();
	protected boolean defaultSourceAllowed = false;
	protected boolean queryHeadParsing = false;
	static GmqlQueryParserException customParsingException;
	protected List<GenericEntity> objectWithSourceList = new ArrayList<GenericEntity>();
	protected Map<String, Variable> variableMap = new HashMap<String, Variable>();
	
	
	/**
	 * This method retrieves the resulting query from the parsing.
	 * 
	 * It assumes that there are NO errors encountered during parsing
	 *
	 */
	public Object getResult() {
		if (contextMap.size() != 1)
			throw new GmqlQueryParserException("GMQL Query not parsed correctly, " + contextMap.size() + " items exist as possible results.");

		processRegistry(true);

		Set<ParserRuleContext> keySet = contextMap.keySet();
		// should be one item at this point only
		for (ParserRuleContext ctx : keySet) {
			CustomContext<?> customContext = contextMap.get(ctx);
			Object returnValue = customContext.getReturnValue();
			if (returnValue instanceof Query) {
				return returnValue;
			} else {
				throw new GmqlQueryParserException("Non Query object was evaluated by the parser:" + returnValue);
			}
		}
		return null;
	}

	public void processRegistry(boolean strictEvaluation) {
		registryManager.validateRegistry(strictEvaluation);
		resolveSourceLink();
	}

	private void resolveSourceLink() {
		for (Object object : objectWithSourceList) {
			if (object instanceof PropertyOperand) {
				PropertyOperand o = (PropertyOperand) object;
				o.setSource(getActualSource(o.getSource()));
			} else if (object instanceof Join) {
				Join o = (Join) object;
				o.setSource(getActualSource(o.getSource()));
			} else if (object instanceof FulltextComparison) {
				FulltextComparison o = (FulltextComparison) object;
				o.setSource(getActualSource(o.getSource()));
			} else if (object instanceof ListIndex) {
				ListIndex o = (ListIndex) object;
				o.setJoin((Join) getActualSource(o.getJoin()));
			} else if (object instanceof MapKey) {
				MapKey o = (MapKey) object;
				o.setJoin((Join) getActualSource(o.getJoin()));
			} else {
				throw new GmqlQueryParserException("Unexpected type attempting to resolve its source link:" + object);
			}
		}
		objectWithSourceList = null;
	}

	private Source getActualSource(Source source) {
		if (source instanceof SourceLink) {
			SourceLink link = (SourceLink) source;
			return link.getSource();
		} else if (source instanceof DefaultSource) {
			return null;
		} else {
			return source;
		}
	}

	public Map<String, Source> getSourcesRegistry() {
		return registryManager.getSourcesRegistry();
	}

	public Map<String, Variable> getVariablesMap() {
		return this.variableMap;
	}
	
	protected void addToObjectsWithSourcesList(GenericEntity object) {
		objectWithSourceList.add(object);
	}

	protected void setValue(ParserRuleContext key, CustomContext<?> value) {
		contextMap.put(key, value);
	}

	protected Variable getVariable(String name, String typeSignature, Object defaultValue) {
		Variable variable = variableMap.get(name);
		if (variable == null) {
			variable = $.variable(name, typeSignature, defaultValue);
			variableMap.put(name, variable);
		} else {
			// we found an already declared variable. 
			if (typeSignature != null || defaultValue != null) {
				// the already declared variable is declared again. let's throw a parser violation.
				setCustomParsingExcpetion(new GmqlQueryParserException("The variable: "+name+" must not be declared multiple times with typeSignature or defaultValue."));
				throw new RuntimeException();
			}
		}
		return variable;
	}

	@SuppressWarnings("unchecked")
	protected <R, C extends CustomContext<R>> C takeValue(ParserRuleContext key) {
		C value = (C) contextMap.remove(key);
		return value;
	}

	@SuppressWarnings("unchecked")
	protected <R, C extends CustomContext<R>> C getValue(ParserRuleContext key) {
		C value = (C) contextMap.get(key);
		return value;
	}

	protected void removeContextList(List<? extends ParserRuleContext> list) {
		for (ParserRuleContext tempCtx : list) {
			takeValue(tempCtx);
		}
	}

	@Override
	public void exitEveryRule(ParserRuleContext ctx) {
		CustomContext<?> existingValue = getValue(ctx);

		if (existingValue == null) {
			DefaultCustomContext currentContext = new DefaultCustomContext(ctx.getText());
			setValue(ctx, currentContext);
		}
		if (ctx.children != null) {
			ctx.children.clear();
		}
	}

	protected void registerSource(String alias, Source source) {
		try {
			registryManager.registerSource(alias, source);
		} catch (GmqlQueryParserException e) {
			// this trick is needed to break from Antlr's internal algorithm
			// while maintaining the actual error itself
			setCustomParsingExcpetion(e);
			throw new RuntimeException();
		}
	}

	protected Source acquireSource(String alias) {
		return registryManager.acquireSource(alias);
	}

	protected Join acquireJoin(String alias) {
		return registryManager.acquireJoin(alias);
	}

	protected boolean validateIfSourceExists(String alias) {
		return registryManager.validateIfSourceExists(alias);
	}

	protected void enableDefaultSource() {
		defaultSourceAllowed = true;
	}

	protected void disableDefaultSource() {
		defaultSourceAllowed = false;
	}

	protected boolean isDefaultSourceEnabled() {
		return defaultSourceAllowed;
	}

	protected void enableQueryHeadParsing() {
		queryHeadParsing = true;
	}

	protected void disableQueryHeadParsing() {
		queryHeadParsing = false;
	}

	protected boolean isQueryHeadParsing() {
		return queryHeadParsing;
	}

	protected static void setCustomParsingExcpetion(GmqlQueryParserException e) {
		customParsingException = e;
	}

	public GmqlQueryParserException getCustomParsingExcpetion() {
		return customParsingException;
	}

	protected String getImplicitAlias(String signature) {
		return signature.substring(signature.lastIndexOf(".") + 1);
	}
	
	protected void propagateChildResult(ParserRuleContext ctx){ 
		if (ctx.children != null && !ctx.children.isEmpty()) {
			Object child = ctx.getChild(0);
			if (child instanceof ParserRuleContext) {
				ParserRuleContext context = (ParserRuleContext) ctx.getChild(0);
				setValue(ctx, takeValue(context));
			}
		}
	}
	
}
