// ============================================================================
// Copyright BRAINTRIBE TECHNOLOGY GMBH, Austria, 2002-2022
// 
// This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
// 
// This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License along with this library; See http://www.gnu.org/licenses/.
// ============================================================================
package tribefire.platform.impl.service;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

import com.braintribe.model.processing.service.api.ServiceProcessor;
import com.braintribe.model.processing.service.api.ServiceProcessorAddressingException;
import com.braintribe.model.processing.service.api.ServiceRequestContext;
import com.braintribe.model.service.api.ServiceRequest;

/**
 * <p>
 * A component for verifying if a {@link ServiceRequest} is compatible to a {@link ServiceProcessor}.
 * 
 * <p>
 * In expert systems, the denotation types mapped to {@code ServiceProcessor}(s) might not necessarily be compatible
 * with the {@code ServiceRequest} specialization expected by
 * {@link ServiceProcessor#process(ServiceRequestContext, ServiceRequest)}.
 * 
 * <p>
 * The purpose of this class is to offer a fail-fast behavior with better error information in such cases, instead of
 * {@link ClassCastException} generated by Java's generic type inference.
 * 
 * <p>
 * Usages:
 * 
 * <p>
 * Re-usable:
 * 
 * <pre>
 * {@code
 * ServiceRequestCompatibilityChecker checker = ServiceRequestCompatibilityChecker.forService(myServiceInstance);
 * checker.check(requestOne);
 * checker.check(requestTwo);
 * }
 * </pre>
 * 
 * <p>
 * One-timer:
 * 
 * <pre>
 * {@code
 * ServiceRequestCompatibilityChecker
 * 	.forService(myServiceInstance)
 * 	.check(myRequest);
 * }
 * </pre>
 * 
 */
public class ServiceRequestCompatibilityChecker {

	private Class<? extends ServiceRequest> serviceProcessorRequestType = null;

	public ServiceRequestCompatibilityChecker(ServiceProcessor<? extends ServiceRequest, ? extends Object> serviceProcessor) {
		resolveServiceProcessorRequestType(serviceProcessor);
	}

	public <D extends ServiceRequest, R extends ServiceRequest> Class<R> check(D denotationInstance, Class<R> expectedType) {

		if (denotationInstance == null) {
			// A null incoming request is considered valid
			return expectedType;
		}

		if (!expectedType.isAssignableFrom(denotationInstance.getClass())) {
			throw new ServiceProcessorAddressingException("The type [ " + denotationInstance.getClass() + " ] is not compatible with the type the service processor expects: [ " + serviceProcessorRequestType + " ] ");
		}

		return expectedType;

	}

	public <D extends ServiceRequest, R extends ServiceRequest> R check(D denotationInstance) {

		if (denotationInstance == null) {
			// A null incoming request is considered valid
			return null;
		}

		if (!serviceProcessorRequestType.isAssignableFrom(denotationInstance.getClass())) {
			throw new ServiceProcessorAddressingException("The type [ " + denotationInstance.getClass() + " ] is not compatible with the type the service processor expects: [ " + serviceProcessorRequestType + " ] ");
		}

		@SuppressWarnings("unchecked")
		R returnType = (R) denotationInstance;
		return returnType;

	}

	public static ServiceRequestCompatibilityChecker forService(ServiceProcessor<? extends ServiceRequest, ? extends Object> serviceProcessor) {
		return new ServiceRequestCompatibilityChecker(serviceProcessor);
	}

	@SuppressWarnings("unchecked")
	protected void resolveServiceProcessorRequestType(ServiceProcessor<? extends ServiceRequest, ? extends Object> serviceProcessor) {

		try {

			for (Method processMethod : serviceProcessor.getClass().getMethods()) {

				if (!processMethod.getName().equals("process") || 
						processMethod.isBridge() || 
						processMethod.getParameterTypes().length != 2 || 
						processMethod.getReturnType() == Void.class || 
						!Modifier.isPublic(processMethod.getModifiers()) || 
						Modifier.isStatic(processMethod.getModifiers())) {
					continue;
				}

				Class<?> firstParam = processMethod.getParameterTypes()[0];
				Class<?> secondParam = processMethod.getParameterTypes()[1];

				if (ServiceRequestContext.class.isAssignableFrom(firstParam) && ServiceRequest.class.isAssignableFrom(secondParam)) {

					Class<? extends ServiceRequest> requestType = (Class<? extends ServiceRequest>) secondParam;

					if (serviceProcessorRequestType == null || requestType.isAssignableFrom(serviceProcessorRequestType)) {
						serviceProcessorRequestType = requestType;
					} 

				}

			}

		} catch (Exception e) {
			throw new ServiceProcessorAddressingException("Incompatible service", e);
		}

		if (serviceProcessorRequestType == null) {
			throw new ServiceProcessorAddressingException("Incompatible service. Failed to identify the actual service request type expected by the service processor "+serviceProcessor);
		}

	}

}
