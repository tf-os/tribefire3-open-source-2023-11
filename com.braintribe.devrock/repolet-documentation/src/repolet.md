### repolet
The repolet is simple Maven (and artifactory) compatible repository used for testing purposes. It is based on undertow, and is used to create controlled dependencies trees so that resolvers can act against it.

Note that when it's launched, it will search for the first free port number between 8080 and 8100. Therefore, the URL that points to the active repo is only known *after* it has been launched. See below for more information.

There are two different versions of the repolet: 

1. the folder-based repolet which uses a local filesystem to store the files, just as artifactory would.
2. the description-based repolet which only requires a description of the content and not the content itself. The description can either by in a specific DSL or simply a YAML file. 

both different repolets support the same functionality. 

```
HttpGet - used to download data from the repolet
HttpPut - used to upload data to the repolet
HttpDelete - used to delete data (that was uploaded before) 
HttpHead - used to retrieve information about a file (all headers, no content)
HttpOptions - used to retrieve options (mostly to mimic artifactory)
```

Compatibilitywise, the repolet strives to be fully compatible to the Maven repository 'standard' and goes through some length mimic *artifactory* so that the client can't see the difference. 


## usage
The repolet can be used to download and upload files, even if its file system is based on a locally prepared selection of files (artifacts plus metadata).

It (and its accompanying tooling) comes from here :

```
com.braintribe.devrock:repolet

```

Your terminal also requires this artifact in order to run the repolet:

```
  <dependency>
     <groupId>org.jboss.xnio</groupId>
     <artifactId>xnio-nio</artifactId>
     <version>3.3.1.Final</version>
  </dependency>
  
```


## generating contents
the [repolet generator](./generator.md) can generate the file-system data that the folder-based repolet is fed with. You can either use a YAML formatted file to setup the content or use a simple expressive text file for the same purpose.

```
com.braintribe.devrock:repolet-generator
```


## setting up the repolet(s)
Once the [generator](./generator.md) has run, it has created a file system that you can use for the folder-based repolet (or, if you let the generator create content for a local repository, just to use it as data for your current local repository).

You can use multiple repolets, but the content of each one needs to be generated by its own.  

# launcher
in order to launch the repolets (most often in your @Before or @BeforeClass tagged functions), you need to create and parameterize the repolet launcher. In order to parameterize it, you can use its configuration builder.

All you need is found here :

```
com.braintribe.devrock:repolet

```

A simple setup (here with 3 folder-based repolets) could look like this

```
private Launcher launcher;
	{
		launcher = Launcher.build()
						.repolet()
							.name( "archiveA")
							.filesystem()
								.filesystem( repoletAContents)
							.close()
						.close()
						.repolet()
							.name( "archiveB")
							.filesystem()
								.filesystem( repoletBContents)
							.close()					
						.close()
						.repolet()
							.name( "archiveC")
							.filesystem()
								.filesystem( repoletCContents)
							.close()					
						.close()
					.done();
	}
```

Configuring an description-based repolet is even easier:

```
private Launcher launcher;
    {
        RepoletContent content = RepositoryGenerations.unmarshallConfigurationFile(configurationFile);
    
        launcher = Launcher.build()
                        .repolet()
                            .name( "archive")
                            .descriptiveContent()
                                .descriptiveContent( content)
                            .close()
                        .close()
                    .done();
    }

```

Of course there's more to the repolet as is shown here. The more complex setups (and the repolet's advanced features) are explained [here](./launcherconfiguration.md).

## LauncherTrait
The artifact sports a trait, i.e. an interface you can derive from that gives you some convenience functions for starting up and shutting down again.

```
com.braintribe.devrock.repolet.launcher.LauncherTrait
```

The trait gives the following functions:

### 'run before' aka launch

```
public Map<String, String> runBefore( Launcher launcher);
```

It accepts your configured launcher, starts it and returns a Map of the repolet's name and the URL it was launched on.

call this within your @Before or @BeforeClass function.

so you can do this:

```
@Before
public void runBefore() {
  Map<String,String> nameToUrlMap = runBefore( launcher);  
}
```

but of course, you can also do this (if you do not want the protocol)

```
@Before
public void runBefore() {
  launcher.launch();
}
```


### 'run after' or shutdown
```
public void runAfter(Launcher launcher);
```
Again, it accepts your configured launcher, but this time shuts it down.

```
@After
public void runAfter() {
  runAfter( launcher);  
}
```

but of course, you can also do this (if you do not want the protocol)

```
@After
public void runAfter() {
  launcher.shutdown();
}
```


### protocolling

the trait also contains a protocolling feature. You can override the following function in order to receive the protocol:

```
void log(String message);
```

Default implementation sends the message to Nirvana.


## notifications

The repolet can send you notifications, based on the types in [repolet-event-model](javadoc:com.braintribe.devrock.model.repolet)

    com.braintribe.devrock:repolet-event-model
    
It is of course based on mc-core's event system (see com.braintribe.devrock:mc-core-documentation for details about that)


You can add yourself as a listener to the repolets (one or more) via the launcher

    launcher.addListener(RepoletInstanceEvent.T, this);


As mc-core's event system is modeled, you can actually define what events you are interested in by specifing the part in the hierarchy you want. There are categories 

    RepoletBaseEvent
        RepoletInstanceEvent
            OnControlEvent  (switching the repolet's content for instance)              
            OnRequestEvent
                OnDeleteRequestEvent
                OnGetRequestEvent
                OnHeadRequestEvent
                OnOptionsRequestEvent
                OnPutRequestEvent
                OnUnsupportedRequestEvent
            OnStreamingEvent
                OnDownloadEvent
                OnUploadEvent
        RepoletLauncherEvent
            OnRepoletLaunchingEvent (pre-launch)
            OnRepoletLaunchedEvent (post-launch)


Basically, there are two main branches: the RepoletInstanceEvent branch which are sent by concrete instantiated repolets and the RepoletLauncherEvent which are sent be the launcher.  


Your listener needs to implement the following [listener](javadoc:com.braintribe.devrock.mc.api.event.EntityEventListener<E extends GenericEntity>). 


    public class myClass implements EventListener<RepoletInstanceEvent> {
        @Override
        void onEvent(EventContext eventContext, RepoletInstanceEvent event) {
            String repoletId = event.getSendingRepoletName();
            ... 
            
        }
    }



# configuration 
You can of course use the repolets anywhere where you want work with 'controlled repository states'. 
This means of course that you can also address them in a settings.xml or in a repository-configuration

## settings.xml

```
    <?xml version="1.0"?>
    <settings>
        <localRepository>${env.m2_repo}</localRepository>		
        <profiles>		
            <profile>
                <id>default</id>
                <repositories>
                    <!-- repolet backed repository 'archiveA' -->
                    <repository>
                        <id>archive</id>
                        <layout>default</layout>
                        <url>http://localhost:${env.port}/archive/</url>					
                        <releases>
                            <enabled>true</enabled>
                            <updatePolicy>never</updatePolicy>
                        </releases>
                    </repository>						
                </repositories>						
            </profile>		
        </profiles>
        <activeProfiles>
            <activeProfile>default</activeProfile>
        </activeProfiles>
    </settings>
```

The settings compiler will automatically look-up the environment variables 'port' and 'm2_repo', and replace it by the value you've set with the virtual environment, see below.


## repository configuration 

    !com.braintribe.devrock.model.repository.RepositoryConfiguration {        
        localRepositoryPath: "${env.m2_repo}",
        repositories: [
            !com.braintribe.devrock.model.repository.MavenHttpRepository {
                name: "archive",                
                url: "http://localhost:${env.port}/archive",
            },
        ],
    }            

Again, the configuration compiler will look-up and the replace the environment variable 'port' and 'm2_repo'.

    Note that while the settings.xml variable replacement happens on a text level - i.e. while parsing the XML file - the variable replacement on the YAML happens *after* it has been turned into instances. Therefore, you can not use variables (which are of String type) in places where another type is expected, for instance boolean. 
    This will be addressed in the future, but for now, there's no support for 'non-string' placeholders in the YAML file.

## specifying the port number
Please note that the URL of the repository has a variable  _port_  referenced.

You need to inject that variable into the system. That is of course done with the VirtualEnvironment.

A typical setup for the VirtualEnvironment would look like this:

```
OverrideableVirtualEnvironment ove = new OverrideableVirtualEnvironment();
ove.addEnvironmentOverride( "port", Integer.toString(launcher.getAssignedPort()));
ove.addEnvironmentOverride( "m2_repo", localRepositoryPath);
```

This OverrideableVirtualEnvironment now needs to be inserted into your wirings (of mc-legacy or mc-core or of your custom wirings).

    Note that the placeholder has to have 'env.' prefixed. It is the convention that a placeholder prefixed with this is considered to be an environment variable. Without the prexfix, it will be considered a system property. You can of course inject both with the virtual enviroment, so it's up to you what to use. In most cases though, the use of an enviroment variable reflects the most common use-cases for the use of variable expressions in these configuration files. 

## notes
### hashes and headers
The repolet will automatically insert hashes for MD5,SHA1 and SHA256 to respective headers during download. And, during upload, will look for the same headers and validate the uploaded file against the hashes (using shortcut logic, i.e. it only checks one).
