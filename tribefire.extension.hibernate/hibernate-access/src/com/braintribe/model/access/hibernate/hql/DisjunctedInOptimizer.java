// ============================================================================
// Copyright BRAINTRIBE TECHNOLOGY GMBH, Austria, 2002-2022
// 
// This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
// 
// This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License along with this library; See http://www.gnu.org/licenses/.
// ============================================================================
package com.braintribe.model.access.hibernate.hql;

import static com.braintribe.utils.lcd.CollectionTools2.acquireSet;
import static com.braintribe.utils.lcd.CollectionTools2.first;
import static com.braintribe.utils.lcd.CollectionTools2.newMap;

import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.braintribe.model.generic.GenericEntity;
import com.braintribe.model.processing.query.planner.condition.QueryConditionBuilder;
import com.braintribe.model.query.Operand;
import com.braintribe.model.query.Operator;
import com.braintribe.model.query.PropertyOperand;
import com.braintribe.model.query.Query;
import com.braintribe.model.query.conditions.Condition;
import com.braintribe.model.query.conditions.ConditionType;
import com.braintribe.model.query.conditions.Disjunction;
import com.braintribe.model.query.conditions.ValueComparison;

/**
 * Optimization for queries with a disjunction of IN conditions like this:
 * 
 * <code><pre>
 * SELECT... FROM Entity e WHERE 
 * 	'red' IN e.colors OR 
 * 	'blue' IN e.colors OR 
 * 	'green' IN e.colors
 * </pre></code>
 * 
 * The problem here is that the straight forward HQL translation generates this:
 * 
 * <code><pre>
 * SELECT... FROM Entity e WHERE
 * 	'red' IN elements(e.colors) OR
 * 	'green' IN elements(e.colors) OR
 * 	'blue' IN elements(e.colors)
 * </pre></code>
 * 
 * This then leads to 3 nested queries in the SQL generated by Hibernate, e.g.:
 * 
 * <code><pre>
 * SELECT... FROM Entity e LEFT OUTER JOIN EntityColor ec ON e.color=ec.id WHERE
 * 	'red' IN (
 * 		SELECT ec2.color FROM EntityColor ec2 WHERE e.id=ec2.entityId
 * 	) OR
 * 	'green' IN (
 * 	...
 * </pre></code>
 * 
 * <h2>Solution:</h2>
 * 
 * We transform such a condition into (using pseudo-notation):
 * 
 * <code><pre>
 * SELECT... FROM Entity e WHERE 
 * 	e.colors INTERSECTS {'red', 'blue', 'green'}
 * </pre></code>
 * 
 * This condition is using {@link Intersects} comparison defined here for HQL building purposes.
 * <p>
 * The resulting HQL then looks like this (and is directly translated to SQL using just this one, explicitly introduced, nested query):
 * 
 * <code><pre>
 * SELECT... FROM Entity e WHERE EXISTS (
 * 		SELECT ee FROM Entity e2 JOIN ee.colors c WHERE e2.id = e.id  AND c IN ('red', 'blue', 'green')
 * )
 * </pre></code>
 * 
 * @author peter.gazdik
 */
/* package */ class DisjunctedInOptimizer {

	public static void optimize(Query q, Disjunction d) {
		Set<GenericEntity> evaluationExcludes = q.getEvaluationExcludes();

		Map<PropertyOperand, Set<Object>> operandToValues = newMap();

		List<Condition> operands = d.getOperands();

		Iterator<Condition> it = operands.iterator();
		while (it.hasNext())
			if (indexDisjunctionOperand(it.next(), operandToValues, evaluationExcludes))
				it.remove();

		for (Entry<PropertyOperand, Set<Object>> e : operandToValues.entrySet())
			operands.add(toValueCompairson(e.getKey(), e.getValue()));
	}

	private static boolean indexDisjunctionOperand(Condition c, Map<PropertyOperand, Set<Object>> operandToValues,
			Set<GenericEntity> evaluationExcludes) {
		if (c.conditionType() != ConditionType.valueComparison)
			return false;

		ValueComparison vc = (ValueComparison) c;
		if (vc.getOperator() != Operator.in)
			return false;

		Object left = vc.getLeftOperand();
		if (isOperand(left, evaluationExcludes))
			return false;

		Object right = vc.getRightOperand();
		if (!isOperand(right, evaluationExcludes) || !(right instanceof PropertyOperand))
			return false;

		acquireSet(operandToValues, (PropertyOperand) right).add(left);
		return true;
	}

	private static boolean isOperand(Object o, Set<GenericEntity> evaluationExcludes) {
		return o instanceof Operand && !evaluationExcludes.contains(o);
	}

	private static Condition toValueCompairson(PropertyOperand operand, Set<Object> values) {
		if (values.size() == 1)
			return QueryConditionBuilder.valueComparison(first(values), operand, Operator.in);
		else
			return Intersects.create(operand, values);
	}

}
