// ============================================================================
// Copyright BRAINTRIBE TECHNOLOGY GMBH, Austria, 2002-2022
// 
// This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
// 
// This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License along with this library; See http://www.gnu.org/licenses/.
// ============================================================================
package org.apache.catalina.loader;

import static org.apache.catalina.loader.Helpers.list;

import java.io.File;
import java.io.FileFilter;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.stream.Collectors;

import javax.servlet.ServletContext;

import org.apache.catalina.Globals;
import org.apache.catalina.LifecycleException;

/**
 * This DevLoader is based on the original DevLoader included in the Eclipse Tomcat Plugin and adds additional
 * features/fixes:
 * <ul>
 * <li><b>Support for DevRock/AC</b>: the plugin looks for web classpath files generated by AC.</li>
 * <li><b>Auto-fix workspace project paths</b>: When not using AC, the DevLoader usually relies on the web classpath
 * file generated by the Tomcat Plugin itself. For dependencies available as source projects in the Eclipse workspace
 * the Tomcat Plugin only provides the project name: <code>/[ProjectName]</code> instead of
 * <code>/absolute/path/to/[ProjectName]/target/classes</code>. The DevLoader tries to fix this automatically by
 * searching the additional project folders relative to the main project directory. Limitations: all workspace project
 * folders must be on the same level as the main project (i.e. same parent directory) and the relative build directory
 * (i.e. the one which contains the compiled classes) must be the same for all projects, for example
 * <code>[ProjectDir]/target/classes</code>.</li>
 * <li><b>Support for external web classpath files</b>:</li> Because of the limitation explained above, the DevLoader
 * also looks for web classpath files generated by the dependency management tool (Gradle, Maven). If these files exist,
 * the DevLoader reads the classpath from there. Expected files are <code>/[ProjectRootDir]/.#webclasspath_gradle</code>
 * (when using Gradle) or <code>/[ProjectRootDir]/.#webclasspath_maven</code> (for Maven).</li>
 * </ul>
 * <p>
 * The DevLoader expects the classpath container (from AC, Gradle or Maven) to be added to DevLoader's classpath in the
 * project settings. Furthermore, when relying on web classpath files created by the Tomcat Plugin, one also has to add
 * the main project to the classpath. Nothing else is needed.<br>
 * Note that this also fixes the problem with user specific paths in the <code>.tomcatplugin</code> file, which means
 * the file can now be committed to the VCS.
 */
public class DevLoader extends WebappLoader {

	/**
	 * Represents the location of the web classpath file.
	 */
	private enum WebClassPathFileLocation {
		RootDir,
		WebAppDir;
	}

	/**
	 * Represents the tool which generates the web classpath file.
	 */
	private enum WebClassPathFileGenerator {
		AC("_ac", WebClassPathFileLocation.RootDir),
		Gradle("_gradle", WebClassPathFileLocation.RootDir),
		Maven("_maven", WebClassPathFileLocation.RootDir),
		TomcatPlugin("", WebClassPathFileLocation.WebAppDir);

		private String fileNameSuffix;
		private WebClassPathFileLocation webClassPathFileLocation;

		private static final String webClassPathFileNamePrefix = ".#webclasspath";

		private WebClassPathFileGenerator(String fileNameSuffix, WebClassPathFileLocation webClassPathFileLocation) {
			this.fileNameSuffix = fileNameSuffix;
			this.webClassPathFileLocation = webClassPathFileLocation;
		}

		private File getWebClassPathFile(File rootDir, File webAppDir) {
			File dir;
			switch (webClassPathFileLocation) {
				case RootDir: {
					dir = rootDir;
					break;
				}
				case WebAppDir:
					dir = webAppDir;
					break;
				default:
					throw new RuntimeException("Unknown enum: " + webClassPathFileLocation);

			}

			return new File(dir, webClassPathFileNamePrefix + fileNameSuffix);
		}
	}

	/**
	 * Represents the dependency management and its respective classpath container.
	 */
	private enum DependencyManagement {
		AC("Braintribe.ArtifactClasspathContainer", list(WebClassPathFileGenerator.AC)),
		Gradle("org.eclipse.buildship.core.gradleclasspathcontainer", list(WebClassPathFileGenerator.Gradle, WebClassPathFileGenerator.TomcatPlugin)),
		Maven("org.eclipse.m2e.MAVEN2_CLASSPATH_CONTAINER", list(WebClassPathFileGenerator.Maven, WebClassPathFileGenerator.TomcatPlugin)),
		TomcatPlugin(null, list(WebClassPathFileGenerator.TomcatPlugin));

		private String containerWebClassPathEntry;
		private List<WebClassPathFileGenerator> orderedSupportedWebClassPathFileGenerators;

		private DependencyManagement(String containerWebClassPathEntry, List<WebClassPathFileGenerator> orderedSupportedWebClassPathFileGenerators) {
			this.containerWebClassPathEntry = containerWebClassPathEntry;
			this.orderedSupportedWebClassPathFileGenerators = orderedSupportedWebClassPathFileGenerators;
		}

		private String getContainerWebClassPathEntry() {
			return containerWebClassPathEntry;
		}

		public List<WebClassPathFileGenerator> getOrderedSupportedWebClassPathFileGenerators() {
			return orderedSupportedWebClassPathFileGenerators;
		}
	}

	/**
	 * Represents the Tomcat Plugin settings specified in the plugin file ({@value DevLoader#tomcatPluginFile}). Only
	 * the settings which are relevant for the DevLoader are read from the file.
	 */
	private static class TomcatPluginSettings {
		private DependencyManagement dependencyManagement;
		private String relativeWebAppDir;

		private TomcatPluginSettings(String fileContent) {
			// the element is called rootDir, but it actually specifies the web app (root) dir, not the project
			relativeWebAppDir = Helpers.getSubstringBetween(fileContent, "<rootDir>", "</rootDir>");

			for (DependencyManagement it : DependencyManagement.values()) {
				if (it.getContainerWebClassPathEntry() != null
						&& fileContent.contains("<webClassPathEntry>" + it.getContainerWebClassPathEntry() + "</webClassPathEntry>")) {
					if (dependencyManagement != null) {
						throw new RuntimeException("Invalid tomcat plugin file content! Found multiple containers in web class path: "
								+ this.dependencyManagement.getContainerWebClassPathEntry() + " and " + it.getContainerWebClassPathEntry());
					}
					dependencyManagement = it;
				}
			}
		}

		public DependencyManagement getDependencyManagement() {
			return dependencyManagement;
		}

		public String getRelativeWebAppDir() {
			return relativeWebAppDir;
		}

	}

	private static final String versionInfo = "BtDevLoader 2.0 for Eclipse Tomcat Plugin 9.1.4+ and Tomcat 9.0.38+";
	private static final String tomcatPluginFile = ".tomcatplugin";
	private static final String classpathFile = ".classpath";

	private static final String property_autoRemoveServletApiFromClassPath = "btdevloader.autoRemoveServletApiFromClassPath";
	private static final String property_autoRemoveServletApiFromClassPath_old = "BtDevLoaderRemoveServletApi";

	/**
	 * This is used for testing purposes to be able to use dummy paths (starting with {@value #dummyPath}) in test files
	 * while still supporting file existence checks.
	 */
	static String dummyPathReplacement;
	static final String dummyPath = "/absolute/path/to";

	public DevLoader() {
		super();
	}

	public DevLoader(ClassLoader parent) {
		super(parent);
	}

	/**
	 * @see org.apache.catalina.Lifecycle#start()
	 */
	@Override
	public void startInternal() throws LifecycleException {

		log("Starting " + versionInfo + ".");

		super.startInternal();

		ClassLoader cl = super.getClassLoader();
		if (!(cl instanceof WebappClassLoaderBase)) {
			logError("Unable to install " + WebappClassLoaderBase.class.getSimpleName() + ", received ClassLoader was: "
					+ ((cl == null) ? "null" : cl.getClass().getName()));
			return;
		}

		@SuppressWarnings("resource") // we must not close this class loader!
		WebappClassLoaderBase devCl = (WebappClassLoaderBase) cl;

		StringBuilder classpathBuilder = new StringBuilder();

		{
			List<String> webClassPathEntries = readWebClassPathEntries(getWebappDir());

			for (String entry : webClassPathEntries) {
				File f = new File(entry);

				if (f.exists()) {
					if (f.isDirectory() && !entry.endsWith("/")) {
						f = new File(entry + "/");
					}
					try {
						URL url = f.toURI().toURL();
						devCl.addURL(url);
						classpathBuilder.append(f.toString()).append(File.pathSeparatorChar);
						// log("Added to classpath: " + url.toString());
					} catch (MalformedURLException e) {
						logError("Web classpath entry " + entry + " is not a valid URL!", e);
					}
				} else {
					logError("Web classpath entry " + entry + " does not exist!");
				}
			}
		}

		log("Classpath: " + classpathBuilder.toString());

		String cp = (String) getServletContext().getAttribute(Globals.CLASS_PATH_ATTR);
		StringTokenizer tokenizer = new StringTokenizer(cp, File.pathSeparatorChar + "");
		while (tokenizer.hasMoreTokens()) {
			String token = tokenizer.nextToken();
			// only on Windows
			if (token.charAt(0) == '/' && token.charAt(2) == ':') {
				token = token.substring(1);
			}
			classpathBuilder.append(token).append(File.pathSeparatorChar);
		}
		// cp = classpath + cp;
		getServletContext().setAttribute(Globals.CLASS_PATH_ATTR, classpathBuilder.toString());
		log("Class path for our application class loader: " + classpathBuilder.toString());
	}

	private static void log(String msg) {
		System.out.println("[DevLoader] " + msg);
	}

	private static void logError(String msg) {
		logError(msg, null);
	}

	private static void logError(String msg, Exception e) {
		System.err.println("[DevLoader] Error: " + msg);
		if (e != null) {
			System.err.println("[DevLoader]   Thrown Exception:\n");
			e.printStackTrace();
		}
	}

	/**
	 * This method finds the project root, reads the TomcatPlugin settings, based on these settings determines the
	 * dependency management tool, finds the web classpath file and reads the web classpath entries (converting relative
	 * dirs, if needed). This method is package visible and <code>static</code> to make it easily testable.
	 */
	static List<String> readWebClassPathEntries(File webappDir) {
		List<String> rc = null;

		log("Project webapp directory: " + webappDir.getAbsolutePath());
		File projectRootDir = getProjectRootDir(webappDir);
		if (projectRootDir == null) {
			return new ArrayList<>();
		}
		log("Project root directory:   " + projectRootDir.getAbsolutePath());

		TomcatPluginSettings tomcatPluginSettings = new TomcatPluginSettings(Helpers.readFileContent(new File(projectRootDir, tomcatPluginFile)));

		rc = loadWebClassPathFile(projectRootDir, tomcatPluginSettings);

		if (rc.isEmpty()) {
			logError("No web classpath entries!");
		}

		return rc;
	}

	/**
	 * Finds and returns the project root directory by traversing ancestor directories and searching file
	 * {@value #tomcatPluginFile}.
	 */
	private static File getProjectRootDir(File webappDir) {
		File currentDir = webappDir;
		File rootDir = null;

		FileFilter filter = file -> file.getName().equalsIgnoreCase(tomcatPluginFile);

		while (currentDir != null) {
			File[] files = currentDir.listFiles(filter);
			if (files != null && files.length >= 1) {
				rootDir = files[0].getParentFile();
				break;
			}
			currentDir = currentDir.getParentFile();
		}

		if (rootDir == null) {
			logError("No project root directory found! Searched from " + webappDir + ".");
		}

		return rootDir;
	}

	private static List<String> loadWebClassPathFile(File projectRootDir, TomcatPluginSettings tomcatPluginSettings) {

		String normalizedProjectRootDirPath = Helpers.normalizePath(projectRootDir);
		File webAppDir = new File(projectRootDir, tomcatPluginSettings.getRelativeWebAppDir());
		List<File> webClassPathFiles = new ArrayList<>();
		List<File> checkedWebClassPathFiles = new ArrayList<>();

		WebClassPathFileGenerator webClassPathFileGenerator = null;

		DependencyManagement dependencyManagement = tomcatPluginSettings.getDependencyManagement();
		if (dependencyManagement == null) {
			String classpathFileContent = Helpers.readFileContent(new File(projectRootDir, classpathFile));
			if (classpathFileContent.contains(DependencyManagement.AC.getContainerWebClassPathEntry())) {
				dependencyManagement = DependencyManagement.AC;
				log("Warning: found AC in " + classpathFile
						+ " file, but the container is not selected in the DevLoader classpath in Tomcat Plugin settings."
						+ " Future versions of the DevLoader may depend on it. Therefore please select the container to get rid of this warning!");
			} else {
				throw new RuntimeException(
						"Warning: no container selected in the DevLoader classpath in Tomcat Plugin settings. Please select the respective container (e.g. Maven, Gradle)!");
			}
		}

		for (WebClassPathFileGenerator supportedWebClassPathFileGenerator : dependencyManagement.getOrderedSupportedWebClassPathFileGenerators()) {
			File webClassPathFile = supportedWebClassPathFileGenerator.getWebClassPathFile(projectRootDir, webAppDir);
			checkedWebClassPathFiles.add(webClassPathFile);
			if (webClassPathFile.exists()) {
				log("Found web classpath file " + webClassPathFile + " generated by " + supportedWebClassPathFileGenerator.name() + ".");
				webClassPathFiles.add(webClassPathFile);
				// set webClassPathFileGenerator, but only if not set yet (first one wins, see ordered list above)
				if (webClassPathFileGenerator == null) {
					webClassPathFileGenerator = supportedWebClassPathFileGenerator;
				}
			}
		}

		if (webClassPathFiles.isEmpty()) {
			throw new RuntimeException("No web classpath file found! None of the following file(s) exists: " + checkedWebClassPathFiles);
		}

		if (webClassPathFileGenerator == null) {
			throw new RuntimeException("No " + WebClassPathFileGenerator.class.getSimpleName() + " set. Since we found some web class path files ("
					+ webClassPathFiles + ")," + " this should not happen and is a bug in " + DevLoader.class.getName() + " code!");
		}

		File webClassPathFile = webClassPathFiles.get(0);
		log("Using web classpath file " + webClassPathFile.getAbsolutePath() + ".");

		List<String> paths = Helpers.readFileLines(webClassPathFile).stream().map(path -> Helpers.normalizePath(path)).collect(Collectors.toList());

		if (dummyPathReplacement != null) {
			// just for testing purposes, see method Javadoc
			paths = replaceDummyPaths(paths);
		}

		if (autoRemoveServletApi()) {
			paths = paths.stream().filter(path -> {
				if (path.contains("/javax.servlet-api-")) {
					log("Removing servlet api classpath entry (" + path + "). This removal can be deactivated via system property: -D"
							+ property_autoRemoveServletApiFromClassPath + "=false");
					return false;
				}
				return true;
			}).collect(Collectors.toList());
		}

		if (webClassPathFileGenerator.equals(WebClassPathFileGenerator.TomcatPlugin)) {
			// TomcatPlugin writes wrong paths for dependencies which are available as projects in the Eclipse workspace
			// --> we have to fix that
			paths = fixWorkspaceProjectsPath(paths, normalizedProjectRootDirPath);
		}

		return paths;
	}

	/**
	 * Fixes paths for workspace projects, see {@link DevLoader class documentation}.
	 */
	private static List<String> fixWorkspaceProjectsPath(List<String> paths, String projectRootDirPath) {

		String compiledClassesDirSuffix = null;
		File workspaceProjectsParentDir = null;
		String projectBuildDirPath = null;

		// first we have to search the entry for our (main) project (i.e. the one with the TomcatPlugin file)
		for (String path : paths) {

			if (path.startsWith(projectRootDirPath)) {
				if (projectBuildDirPath != null) {
					throw new RuntimeException("Unexpectedly found multiple project dir paths: " + path + ", " + projectBuildDirPath
							+ " (This is not supported by DevLoader. Either there is a problem in the setup or a bug in the DevLoader implementation.)");
				}

				// this is our project dir, e.g. "/absolute/path/to/my-module/target/classes"
				// we want to extract "target/classes"
				projectBuildDirPath = path;
				compiledClassesDirSuffix = path.substring(projectRootDirPath.length());
				workspaceProjectsParentDir = new File(projectRootDirPath).getParentFile();
			}
		}

		List<String> fixedPaths = new ArrayList<>();

		if (compiledClassesDirSuffix != null) {
			for (String path : paths) {
				String fixedPath = null;
				if (!path.matches("^/[^/]+$")) {
					// nothing to fix
					fixedPath = path;
				} else {
					// nothing to fix
					File fixedProjectDir = new File(workspaceProjectsParentDir, path);

					if (fixedProjectDir.exists()) {
						File fixedProjectCompiledClassesDir = new File(fixedProjectDir, compiledClassesDirSuffix);
						String fixedProjectCompiledClassesDirPath = fixedProjectCompiledClassesDir.getAbsolutePath();

						if (fixedProjectCompiledClassesDir.exists()) {
							log("Converting web classpath entry '" + path + "' to '" + fixedProjectCompiledClassesDirPath + "'.");
							fixedPath = fixedProjectCompiledClassesDirPath;
						} else {
							logError("Would use build path '" + fixedProjectCompiledClassesDir + "' for entry '" + path
									+ "' in web classpath file, but path doesn't exist!");
						}
					} else {
						logError("Would use path '" + fixedProjectDir + "' for entry '" + path + "' in web classpath file, but path doesn't exist!");
					}
				}
				if (fixedPath != null) {
					fixedPaths.add(fixedPath);
				}
			}
		} else {
			throw new RuntimeException("Didn't find project dir '" + projectRootDirPath
					+ "' in web class path entries. Please add the project to the DevLoader's classpath!");
		}

		return fixedPaths;
	}

	private ServletContext getServletContext() {
		return getContext().getServletContext();
	}

	private File getWebappDir() {
		File webAppDir = new File(getServletContext().getRealPath("/"));
		return webAppDir;
	}

	private static boolean autoRemoveServletApi() {
		if (System.getProperty(property_autoRemoveServletApiFromClassPath_old) != null) {
			log("WARNING: Ignoring old property '" + property_autoRemoveServletApiFromClassPath_old + "'. Please use '"
					+ property_autoRemoveServletApiFromClassPath + "' instead!");
		}

		return Helpers.getBooleanSystemPropertyValue(property_autoRemoveServletApiFromClassPath, true);
	}

	/**
	 * Replaces dummy paths with real paths that exist on the file system. (This is just used to simplify testing.)
	 */
	static List<String> replaceDummyPaths(List<String> paths) {
		return paths.stream().map(path -> path.replace(dummyPath, dummyPathReplacement)).collect(Collectors.toList());
	}

}
